[ { "title": "SondeHub Radiosondy Ingest", "url": "/blog/posts/sondehub-radiosondy/", "categories": "SondeHub", "tags": "", "date": "2022-06-18 14:00:00 +1000", "snippet": "The SondeHub Tracker and Radiosondy.info site are the two major tracking tools for global radiosonde flights with both featuring hundreds of stations and users.The sites both include functionality for users to report recovery information to a central database which can be used to generate leaderboards and reduce waste.Reporting RecoveriesThe primary concept around reporting recoveries is assigning the recovery to a specific radiosonde and user.This requires that the recovered Radiosonde has been previously tracked so that the serial information is available.The recovery can then be lodged against the specific serial along with information regarding the finder and the process.This information can be used to keep track of which radiosondes may still be available to recover and allow users to compare recoveries.Radiosonde SerialsThe sites both support a variety of radiosondes created by various manufacturers and launched globally.The telemetry formats for these devices are often not publically documented so decoders are often created from limited data.This lack of a formal specification for radiosondes can result in the decoded data from different programs for the same flight not being equal.This inconsistency is addressed by limiting which devices can upload to each network but introduces complexitity when attempting to transfer data between sites.The most popular radiosonde is the Viasala RS41 accounting for approximately 85% of global launches with most decoders producing the same output for all non-temperature related fields.The other supported radiosondes often include less similar decoding algorithms between programs including different ways of generating a unique serial number.To succesfully import radiosonde recovery data the serial numbers have to be matched between the two sites.Getting RecoveriesThe private Radiosondy.info recovery API is used to programatically get the recovery reports.The API requires an API token and a time period in hours to return recovery reports for.https://radiosondy.info/api/v1/sonde-logs?token={token}&amp;period=48{ \"results\": [ { \"radiosonde\": { \"number\": \"ME1622EBB\", \"type\": \"M10\", \"aux\": \"NO\", \"qrg\": \"403.400\", \"start_place\": \"Murcia (ES)\" }, \"log_info\": { \"status\": \"FOUND\", \"finder\": \"azofaifo\", \"added_by\": \"azofaifo\", \"log_added\": \"2022-06-18 10:18:02\", \"comment\": \"In the corner of a house, in a small town 2 minutes from where I live.\", \"found_coordinates\": { \"latitude\": \"38.0989\", \"longitude\": \"-1.2775\" } }, \"start_time\": \"2022-06-17 23:18:52\", \"nearest_city\": \"Ceuti (ES)\" } ]}Swagger UI APIThe following Swagger UI component can be used to access the Radiosondy.info Recovery API and get real results.Mapping SerialsThe recovery data from Radiosondy.info includes information about the specific radiosonde and the finder.The radiosonde data includes the specific model which is used to check if the serial can be matched directly.When the serial needs to be matched the provided radiosonde information is used with the SondeHub Sondes API to search for a match.The recovery position and launch time are used to search for any data packets in the SondeHub database within 2000m of the provided location in a three hour window.searchParams = \"?lat={}&amp;lon={}&amp;distance=2000&amp;last={}\".format(lat, lon, searchSeconds)The results of this search are then checked to see if the radiosonde type and transmission frequency match what was reported by Radiosondy.infoif value[\"type\"] in sondeType: if abs(float(sondeFrequency) - float(value[\"frequency\"])) &lt; 0.05:These parameters allow the radiosonde serial to be matched with a high degree of certainty.The specific Python code and Elasticsearch Query for generating the API response can be found here.https://api.v2.sondehub.org/sondes?lat=-34.94449&amp;lon=138.91148&amp;distance=2000{ \"106-2-13771\":{ \"2022-06-18T01:22:08.000Z\":{ \"software_name\":\"radiosonde_auto_rx\", \"software_version\":\"1.5.10\", \"uploader_callsign\":\"EA5BZ\", \"uploader_position\":\"38.2768,-0.6711\", \"uploader_antenna\":\"1/4 wave monopole\", \"time_received\":\"2022-06-18T01:22:08.746528Z\", \"datetime\":\"2022-06-18T01:22:08.000000Z\", \"manufacturer\":\"Meteomodem\", \"type\":\"M10\", \"serial\":\"106-2-13771\", \"frame\":1339550546, \"lat\":38.09909, \"lon\":-1.27771, \"alt\":526.16, \"temp\":27.4, \"humidity\":27.4, \"vel_v\":-10.31, \"vel_h\":1.04389, \"heading\":113.12652, \"sats\":11, \"batt\":4.97, \"frequency\":403.404, \"snr\":4.8, \"user-agent\":\"Amazon CloudFront\", \"position\":\"38.09909,-1.27771\", \"upload_time_delta\":-1.168, \"uploader_alt\":120.0, \"uploaders\":[ { \"uploader_callsign\":\"EA5BZ\", \"frequency\":403.404, \"snr\":4.8 } ] } }}Swagger UI APIThe following Swagger UI component can be used to access the SondeHub Sondes API and get real results.Existing ReportsSome users may report their radiosonde recovery to both sites in which case the Radiosondy.info recovery should not be imported unless it contains new information.The recovery report can either be classified as found or lost depending on if the radiosonde was succesfully retrieved.A single radiosonde can have multiple recovery reports if the first attempt did not result in retrieval but a subsequent attempt did.The decoded or matched serial is used with the SondeHub Recovery API to check for existing reports.recoveryCheckParams = \"?serial={}\".format(serial)The status of the latest report is checked and if a valid recovery already exists the import process for that specific radiosonde is skipped.The specific Python code and Elasticsearch Query for generating the API response can be found here.https://api.v2.sondehub.org/recovered?serial=106-2-13771[ { \"datetime\":\"2022-06-18T10:18:02\", \"serial\":\"106-2-13771\", \"lat\":38.0989, \"lon\":-1.2775, \"recovered\":true, \"recovered_by\":\"azofaifo\", \"description\":\"In the corner of a house, in a small town 2 minutes from where I live. [via Radiosondy.info]\", \"position\":[ -1.2775, 38.0989 ] }]Swagger UI APIThe following Swagger UI component can be used to access the SondeHub Recovery API and get real results.Creating ReportThe recovery report can be created once a valid serial has been found and the SondeHub database has been checked for existing valid reports.This requires that the provided fields from Radiosondy.info are parsed and translated into the required fields for SondeHub.The finder, time, description, position, and serial are all extracted and submitted as a new recovery to SondeHub using the API.AutomationThe complete Python script used to complete this process can be found here.The script is hosted on AWS alongisde other SondeHub infrastructure and is run on the hour with aproximately 30 recoveries imported each day.The ingestion program has seen &gt;5000 reports imported over the previous months with Radiosondy.info also implementing a asystem to import SondeHub reports.This has resulted in almost universal coverage of recovery reports across the two sites improving the experience for all users." }, { "title": "SondeHub Tracker Optimisations", "url": "/blog/posts/sondehub-optimisations/", "categories": "SondeHub", "tags": "", "date": "2022-06-15 14:00:00 +1000", "snippet": "The SondeHub Tracker is an updated fork of the Habhub Tracker to utilise the new SondeHub OpenSearch Radiosonde database.The original Habhub Tracker was created over 10 years ago and contains numerous legacy features that impact performance on modern systems.The original tracker was not intended to handle the high volume of live flights now recorded in the SondeHub database from over 800 stations.This increased load warranted several major modifications to the code to switch to newer and faster technologies.LeafletThe Habhub Tracker uses the Google Maps API which since June 2018 had begun costing a considerable amount to use after Google updated the pricing structure.This cost consideration along with a desire to switch to a faster open-source alternative drove the decision to switch to Leaflet for the tracker.This migration required considerable effort as several Google Maps API features didn’t have compatible replacements in Leaflet so they had to be redesigned or created.The major changes included duplicating the custom controls for time-period selection, map switching, and map scale.This switch brought a considerable performance improvement to the tracker before any specific optimisations were implemented.Canvas RenderingThe next major factor limiting the performance of the tracker was rendering the increased number of station icons and balloon paths as the network had grown.These issues could be addressed by switching to canvas rendering by changing the Leaflet default which resulted in an instant improvement.The existing icons couldn’t be easily rendered on the canvas and had also begun to clutter the interface so the decision to switch to a minimalistic circular design that could be drawn to the canvas.The new design resulted in a significant reduction in the number of items that had to be individually rendered during map operations allowing smooth panning and zooming of the map.This new icon style also allowed the tracker to have a more cohesive design with launch site markers featuring a similar design.The actual balloon icons couldn’t be easily rendered on the canvas so these remain an area for further improvement.WebSocketsThe first iteration of the SondeHub tracker aimed to closely replicate the Habhub tracker so all existing API endpoints were duplicated and modified to query the new SondeHub database.These existing API endpoints were not designed with the frequency and quantity of data now received by SondeHub in mind so they required updating to reduce operating costs and improve speeds.The decision was made to switch to a Websockets-based solution so that live telemetry data could be streamed to the tracker allowing for faster updates and higher data resolution.This switch also came with the benefit of significantly reduced operating costs which allowed the tracker to remain sustainable as active users increased.The tracker code required several modifications so that the existing API endpoints would only be called on page load to fetch historical data while WebSockets would be used for all future data.The WebSockets stream only includes flight data with other information such as flight predictions still retrieved by regularly polling specific API endpoints.Time PeriodsThe Habhub tracker included selectable time periods for flight data of up to 3 days which would result in the SondeHub tracker crashing as this would contain over 1000 flights.The default time period was reduced to 3 hours on the SondeHub tracker which is suitable for viewing the most recent flights without significantly impacting performance.The introduction of WebSockets allowed for the addition of a new live time period that only displays data received from WebSockets without fetching any historical info.This mode is extremely fast and still allows for the entire history of individual flights to be loaded if manually selected.Visibility ConfigurationThe option to disable various map layers was added so that only the desired information would be displayed which results in performance improvements when not all layers are enabled.The receiver stations, launch sites, chase cars, horizon rings, and titles can all be individually hidden with the user preference remembered between sessions.These changes can also be applied without requiring a full refresh of the tracker ensuring that specific entities can quickly be checked.Selective DisplayThese performance improvements made the tracker responsive in modern desktop environments however on certain mobile devices the tracker could still suffer during peak times.The suggestion to only update and display information for flights currently visible on the screen allowed for time savings in the rendering and calculation pipeline increasing responsiveness.The map bounds are recorded and new flight positions are checked against these bounds and if excluded the calculation of certain visual elements such as graphs and sidebar inclusion are skipped.This feature can also improve the user experience by improving navigation and finding the desired information for a local area when there are hundreds of live flights globally." }, { "title": "SondeHub Site Suggestions", "url": "/blog/posts/sondehub-suggestions/", "categories": "SondeHub", "tags": "", "date": "2022-05-24 14:00:00 +1000", "snippet": "This blog post details how I created an automated system to collect user suggestions.SondeHub TrackerThe SondeHub Tracker is an online website where you can view live weather balloon launches across the world.The Tracker relies on the SondeHub database which consists of over 800 ground stations contributing live flight information to the database.This data is processed and shown to users on the SondeHub tracker enabling recovery of radiosondes and basic weather predictions.SondeHub Sites APIThe majority of radiosondes tracked are launched on a regular schedule from a fixed location by national meteorological services.The SondeHub database includes a crowd-sourced database of known radiosonde launch sites along with information such as launch times, radiosonde types, and flight parameters.This data can be used to generate real-time flight predictions and group flights for historical analysis.The SondeHub Sites API returns this list of all known radiosonde launch sites which is then used in the SondeHub Tracker.https://api.v2.sondehub.org/sites\"94672\": { \"station\": \"94672\", \"station_name\": \"Adelaide Airport (Australia)\", \"position\":[ 138.5203, -34.9525 ], \"alt\": 6, \"rs_types\":[ \"41\" ], \"times\":[ \"0:12:00\", \"0:00:00\" ], \"ascent_rate\": 4.3, \"burst_altitude\": 27000} The specific Python code and Elasticsearch Query for generating the API response can be found here.The following Swagger UI component can be used to access the SondeHub Sites API and get real results.The SondeHub Sites API uses a simple data structure for each station with mandator fields for location, name, id, and sonde type in addition to numerous optional fields.These extra fields can include data such as the launch schedule, frequency that the radiosondes transmit on, specific notes, and flight parameters for ascent, burst, descent.The API can either return a single station given its ID or the list of all known stations which is used in the Tracker to display all launch sites on the map.The API is also used internally to lookup flight parameters for any sonde that originates from that launch site and to archive flights after their completion.Site SuggestionsThe SondeHub Tracker includes an integrated modal that allows users to suggest changes to any launch site on the map.This modal contains a customised hyperlink containing all the existing information for the launch site so that only the changes need to be supplied.Google FormsThe original plan was to only use GitHub issues for all site suggestions however after trialling this approach it seemed that respondents were often confused.The GitHub API allows for customised APIs that will automatically pre-fill the text and title fields for a new issue however this functionality is not supported for individual comments on an existing issue.This limitation forced the use of Google Forms as it supported all form fields being prefilled from the URL.Form FieldsThe main consideration in designing the Google Form was to ensure that the correct data was collected in a suitable format.This was achieved by splitting the form into three sections where the first contained the common fields mandatory for all stations.The second section contained all the optional fields that might not yet exist for any particular station while the last section allowed users to submit any extra notes.Field Validity ChecksGoogle Forms supports adding a custom regex check to each field that allows for extreme control over what inputs can be submitted.The checks for certain fields such as ID, altitude, and flight parameters were all created with simple number checks.The station name field required a custom regex to ensure that the correct naming structure was followed with the country placed in brackets at the end.The station coordinates field required a significantly more complex regex sequence that I borrowed from Stack Overflow which ensures the value is generally valid.Field AutofillThe Google Form assigns a unique ID to every field in the form that can be used to generate the URL used in the Tracker that automatically fills existing fields.The ID for each field could only be determined once the Form had been published but does appear to stay constant even after minor modifications to the form.The ID can be determined by visiting the form and using developer tools to select each field and find the second 9-digit numerical value of [data-params].data-params=\"%.@.[564009759,\"Station ID\",null,0,[[749833526,[],true,[],[[1,10,[],\"5 digit WMO code e.g. 94672\"]],null,null,null,null,null,[null,[]]]],null,null,null,[],null,null,[null,\"Station ID\"]],\"i17\",\"i18\",\"i19\",false]\"The fields can also be determined using the Get pre-filled link integrated into the Google Forms creation pageOnce the ID for each field was recorded a custom URL could be constructed.The value for each field that will be pre-filled needs to be appended to the end of the URL with the following formatentry.796606853=Modify+Existing+Siteentry.749833526=94672The complete URL for the launch site at Adelaide Airport contains most of the available fields.https://docs.google.com/forms/d/e/1FAIpQLSfIbBSQMZOXpNE4VpK4BqUbKDPCWCDgU9QxYgmhh-JD-JGSsQ/viewform?usp=pp_url&amp;entry.796606853=Modify+Existing+Site&amp;entry.749833526=94672&amp;entry.675505431=Adelaide+Airport+(Australia)&amp;entry.1613779787=-34.9525,138.5203&amp;entry.753148337=6&amp;entry.509146334=4.3&amp;entry.1897602989=27000&amp;entry.267462486=6.4This pre-fill functionality isn’t easily implemented for the sondes type and launch times fields so currently these must be manually entered each time.Google Apps ScriptThe Google Form will automatically add the responses to the form to a Google Sheets where Google Apps Script can be setup to automatically run.Google Apps Script is a JavaScript based scripting platform that enables easy integration and automation of tasks with Google applications such as Sheets.When a new launch site suggestion is received a custom Apps Script is executed to process the suggestion and publish it to GitHub as a new comment on the main issue.Processing FieldsThe script begins by getting the value for each provided field and formatting it into the correct data type.This involves generating lists for coordinates, launch times, and sonde types in addition to reading flight parameters as floats.The submission results are provided exactly as they are presented in the form so the launch times and sonde types need to be converted to the format used in the API.This involves stripping the text from the sonde types to get the numerical id.var station_types = e.values[6].split(',');if (e.values[6].length &gt; 0) { for (var i = 0; i &lt; station_types.length; i++) { matches = station_types[i].match(/\\(([^)]+)\\)/) if (matches != null &amp;&amp; matches.length &gt; 1) { station_types[i] = matches[1]; } }}The process for launch times is more manual with only the most common times getting automatically converted to our UTC date format.day:hour:minuteDaily 00Z -&gt; 0:00:00Monday 18Z -&gt; 1:18:00Sunday 12Z -&gt; 7:12:00var station_times = e.values[7].split(',');if (e.values[7].length &gt; 0) { for (var i = 0; i &lt; station_times.length; i++) { station_times[i] = station_times[i].trim(); if (station_times[i] == \"Daily 00Z\") { station_times[i] = \"0:00:00\" } if (station_times[i] == \"Daily 12Z\") { station_times[i] = \"0:12:00\" } }}Check ExistingThe script attempts to download the existing records for the site if they exist to determine the differences between the current and proposed fields.var url = \"https://api.v2.sondehub.org/sites?station=\" + station_id;var options = { \"method\": \"GET\", \"contentType\": \"application/json\"};var response = UrlFetchApp.fetch(url, options);existing = JSON.parse(response.getContentText());To compare the new entry it must be stored in the same format as served by the API.This process will also import the launch times and sonde types if they exist for the station and the user hasn’t proposed any changes to them.The two objects can then be compared relatively easy using a generic difference function.This example from Stack Overflow did the job well with some minor modifications.The reason that such a function is required is due to arrays from the API being equal regardless of their actual order.The function returns a new object which lists all the additions, modifications, and removals to individual properties from the existing entry{ \"27459\": { \"ascent_rate\": { \"type\": \"created\", \"data\": 4.5 }, \"burst_altitude\": { \"type\": \"created\", \"data\": 27000 }, \"descent_rate\": { \"type\": \"created\", \"data\": 25 } }}GitHub IssuesTo post the suggested changes as a GitHub comment the data must be formatted as a single Markdown string.Generate MarkdownThe comment uses various GitHub Markdown features such as expanding modals and embedded maps.The first section of the comment contains the raw unprocessed suggestions which allows for manual inspection and review.The field names are bolded using ** while new lines are created with \\n.\"**Time Submitted:** \" + e.values[0] + \"\\n\"Generate MapThe next section is an expandable map showing the proposed or existing solution of the launch site on an interactive map.GitHub has recently added support for displaying geoJSON data on an interactive map in comments and files.To show the launch site on the map a geoJSON file must be constructed using the provided coordinates and altitude.```geojson{ \"type\":\"Feature\", \"geometry\":{ \"type\":\"Point\", \"coordinates\":[ -58.5333, -34.8167, 20 ] }, \"properties\":{ \"marker-size\":\"large\", \"marker-symbol\":\"observation-tower\", \"Station ID\":\"87576\", \"Station Name\":\"Ezeiza Aerodrome (Argentina)\" }}```The properties define the size, type, and location of the icon displayed on the map along with some additional information such as station name and ID that is visible in a modal on icon selection.The code used to generate this simply inserts the position along with the station name and ID into the string.Hidden ModalsTo reduce the overall size of the comment most of the data is hidden behind expandable modals which are created using the HTML details and summary tags.&lt;details&gt;&lt;summary&gt;View map&lt;/summary&gt; &lt;p&gt;Hidden Text!&lt;/p&gt;&lt;/details&gt;Raw JSONThe existing, suggested, and difference JSON files are also included in the comment under separate modals for reference.These are generated using JSON.stringify() and the same modals as above.Publishing to GitHubThe GitHub API is used to create a new comment on the issue on the SondeHub Tracker with all the information.The comments are published via my personal account using an authorisation token.Updating the DatabaseThe Elasticsearch database containing the launch sites list is still manually updated to ensure no errors are introduced.The automatic formatting of submissions into the correct JSON format simplifies this process considerably allowing for faster updates." }, { "title": "SondeHub Stats Badges", "url": "/blog/posts/sondehub-badges/", "categories": "SondeHub", "tags": "", "date": "2022-05-19 14:00:00 +1000", "snippet": "This blog post contains instructions on how to use Shields.io with a custom API to create custom status badges.Shields.ioShields.io is a free tool that can be used to create metadata badges which can easily be added to open source projects.The most common usecase is showing key project information such as usage and code coverage on sites like GitHub.Creating BadgesShields.io creates these metadata badges from the arguments provided in the URL and returns an image which can be embedded.Several preconfigured badges exist for common services and statistics such as code analysis, quality, coverage, etc.The following badge shows the last time this blog was updated.https://img.shields.io/github/last-commit/LukePrior/blogStyling BadgesThe badges all share the same styling options allowing for a consistent design across a site or project.The five available styles for each badge include plastic, flat, flat-square, for-the-badge, and social.https://img.shields.io/github/last-commit/LukePrior/blog?style=plastichttps://img.shields.io/github/last-commit/LukePrior/blog?style=flathttps://img.shields.io/github/last-commit/LukePrior/blog?style=flat-squarehttps://img.shields.io/github/last-commit/LukePrior/blog?style=for-the-badgehttps://img.shields.io/github/last-commit/LukePrior/blog?style=socialLogo BadgesIcons can be included alongside text in badges by selecting an existing design from simple-icons or providing a custom base64-encoded image.The simple-icons repository contains &gt;2000 available icons which can be added to any badge by including their name in the logo field.The complete list of available icons and their corresponding names can be found on the simple-icons repository here.https://img.shields.io/github/last-commit/LukePrior/blog?style=for-the-badge&amp;logo=githubTo display a custom icon the image must be encoded in base64 with the total file size less then 8192 bytes so that it can fit within the request header.https://img.shields.io/github/last-commit/LukePrior/blog?style=for-the-badge&amp;logo=image/png;base64,...The horizontal padding around icons can be configured using the logoWidth field to allow for larger or smaller badges.https://img.shields.io/github/last-commit/LukePrior/blog?style=for-the-badge&amp;logo=github&amp;logoWidth=40Colouring BadgesThe individual sections of badges can be coloured including the logo and left/right sections of the badge.These fields can all be styled using a variety of schemes including (hex, rgb, rgba, hsl, hsla, css named colours).The logo colour can only be configured when using named icons from simple-icons by using the logoColor field.https://img.shields.io/github/last-commit/LukePrior/blog?style=for-the-badge&amp;logo=github&amp;logoColor=redThe left side background colour can be set using the labelColor field.https://img.shields.io/github/last-commit/LukePrior/blog?style=for-the-badge&amp;labelColor=redThe right side background colour can be set using the color field.https://img.shields.io/github/last-commit/LukePrior/blog?style=for-the-badge&amp;color=redCustom badgesShields.io can also generate a custom badge from any publically accessible JSON, XML, or YAML file.The dynamic badge type accepts a data source and query along with options for text formatting.https://img.shields.io/badge/dynamic/json?url=&lt;URL&gt;&amp;label=&lt;LABEL&gt;&amp;query=&lt;$.DATA.SUBDATA&gt;&amp;color=&lt;COLOR&gt;&amp;prefix=&lt;PREFIX&gt;&amp;suffix=&lt;SUFFIX&gt;The url field is used to specify the location of the data file that will be used to generate the badge.The query field is used to select the correct subdata from the loaded file.The prefix and suffix fields allow text to be added to the start and end of the loaded data.This functionality was used to generate the badges in the SondeHub Wiki.SondeHub Listener Stats APIThe SondeHub Listener Stats API returns information about the number of receiver stations that have uploaded telemetry to the SondeHub radiosonde tracking database.https://api.v2.sondehub.org/listeners/stats{ \"radiosonde_auto_rx\": { \"telemetry_count\": 46867907, \"unique_callsigns\": 620, \"versions\": { \"1.5.10\": { \"telemetry_count\": 31942436, \"unique_callsigns\": 390 } } }, \"rdzTTGOsonde\": { \"telemetry_count\": 11768771, \"unique_callsigns\": 221 }, \"totals\": { \"unique_callsigns\": 847, \"telemetry_count\": 58737217 }}The specific Python code and Elasticsearch Query for generating the API response can be found here.The following Swagger UI component can be used to access the SondeHub Listener Stats API and get real results.This data is used to generate badges for the total number of stations along with counts for each software type.The SondeHub Listener Stats API URL is provided along with a query to get the figure desired for each badge along with a suffix and prefix.https://img.shields.io/badge/dynamic/json?label=Total&amp;query=totals.unique_callsigns&amp;suffix=%20Stations&amp;url=https%3A%2F%2Fapi.v2.sondehub.org%2Flisteners%2Fstats&amp;style=for-the-badgehttps://img.shields.io/badge/dynamic/json?label=radiosonde_auto_rx&amp;query=radiosonde_auto_rx.unique_callsigns&amp;suffix=%20Stations&amp;url=https%3A%2F%2Fapi.v2.sondehub.org%2Flisteners%2Fstats&amp;style=for-the-badgehttps://img.shields.io/badge/dynamic/json?label=rdzTTGOsonde&amp;query=rdzTTGOsonde.unique_callsigns&amp;suffix=%20Stations&amp;url=https%3A%2F%2Fapi.v2.sondehub.org%2Flisteners%2Fstats&amp;style=for-the-badgehttps://img.shields.io/badge/dynamic/json?label=SondeMonitor&amp;query=SondeMonitor.unique_callsigns&amp;suffix=%20Stations&amp;url=https%3A%2F%2Fapi.v2.sondehub.org%2Flisteners%2Fstats&amp;style=for-the-badgeSondeHub Recovery Stats APIThe SondeHub Recovery Stats API returns information about the number of radiosondes that have been marked as retrieved in the SondeHub database.https://api.v2.sondehub.org/recovered/stats { \"total\": 5223, \"recovered\": 4823, \"failed\": 486, \"chaser_count\": 1668, \"top_chasers\": { \"LZ4TU\": 93, \"TFDHU\": 83, \"Lobelt\": 54, \"EDDB\": 53 } }The specific Python code and Elasticsearch Query for generating the API response can be found here.The following Swagger UI component can be used to access the SondeHub Listener Stats API and get real results.This data is used to generate badges for the total number of sondes reported and the count of unique finders.The SondeHub Recovery Stats API URL is provided along with a query to get the figure desired for each badge along with a suffix and prefix.https://img.shields.io/badge/dynamic/json?label=Reported&amp;query=total&amp;suffix=%20Sondes&amp;url=https%3A%2F%2Fapi.v2.sondehub.org%2Frecovered%2Fstats&amp;style=for-the-badgehttps://img.shields.io/badge/dynamic/json?label=Recovered&amp;query=recovered&amp;suffix=%20Sondes&amp;url=https%3A%2F%2Fapi.v2.sondehub.org%2Frecovered%2Fstats&amp;style=for-the-badgehttps://img.shields.io/badge/dynamic/json?label=Lost&amp;query=failed&amp;suffix=%20Sondes&amp;url=https%3A%2F%2Fapi.v2.sondehub.org%2Frecovered%2Fstats&amp;style=for-the-badgehttps://img.shields.io/badge/dynamic/json?label=Chasers&amp;query=chaser_count&amp;suffix=%20Chasers&amp;url=https%3A%2F%2Fapi.v2.sondehub.org%2Frecovered%2Fstats&amp;style=for-the-badgeUsage with GitHub MarkdownThese badges can easily be added to any GitHub README, Wiki page, or comment using markdwon.![This is an example badge][https://img.shields.io/github/last-commit/LukePrior/blog]The badges can also be set as hyperlinks with the following markdown.[![This is an example badge][https://img.shields.io/github/last-commit/LukePrior/blog]](https://github.com/LukePrior/blog)" }, { "title": "SondeHub Stations Chart", "url": "/blog/posts/sondehub-chart/", "categories": "SondeHub", "tags": "", "date": "2022-05-18 14:00:00 +1000", "snippet": "This blog post contains instructions on how to use Chart.js to create a custom donut chart specifically designed for showing receiver data from SondeHub.Chart.jsChart.js is a simple JavaScript charting library for creating responsive visualisations of various types and styles.Chart.js can easily be added on an existing website by including the latest version of the library from a CDN or locally.&lt;script type=\"text/javascript\" language=\"javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.js\"&gt;&lt;/script&gt;Donut ChartTo render a chart a canvas element needs to be added to the website&lt;canvas id=\"myChart\" width=\"400\" height=\"400\"&gt;&lt;/canvas&gt;The graph requires a data object which contains the dataset and formatting options for the graph.const data = { labels: [ 'Red', 'Blue', 'Yellow' ], datasets: [{ data: [300, 50, 100], backgroundColor: [ 'rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 205, 86)' ] }]};The graph can now be created and rendered by passing through the canvas element and data object.const ctx = document.getElementById('myChart').getContext('2d');const myChart = new Chart(ctx, { type: 'doughnut', data: data});ResultThe complete code for this example can be found here.Custom Item TooltipsThe default tooltip only shows the label and value for each entry.This can be overriden by creating a custom tooltip which can show the percentage for each entry.const myChart = new Chart(ctx, { type: 'doughnut', data: data, options: { plugins: { tooltip: { enabled: true, callbacks: { label: (ttItem) =&gt; { let sum = 0; let dataArr = ttItem.dataset.data; dataArr.map(data =&gt; { sum += Number(data); }); let percentage = (ttItem.parsed * 100 / sum).toFixed(2) + '%'; return `${ttItem.parsed}: ${percentage}`; } } } } }});ResultThe complete code for this example can be found here.Nested Donut ChartChart.js includes limited nested data support with donut charts by passing through multiple datasets.const data = { labels: [ 'Red', 'Blue', 'Yellow' ], datasets: [{ data: [300, 50, 100], backgroundColor: [ 'rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 205, 86)' ] }, { data: [200, 75, 175], backgroundColor: [ 'rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 205, 86)' ] }]};ResultThe complete code for this example can be found here.This works well when the inner dataset is the same length as the outer dataset however to have sub-categories in the inner-dataset a custom legend handler is required.datasets: [{ data: [300, 50, 100], backgroundColor: [ 'rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 205, 86)' ]}, { data: [150, 150, 50, 75, 25], backgroundColor: [ 'rgb(255, 99, 132)', 'rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 205, 86)', 'rgb(255, 205, 86)' ]}]The sub-entries can be grouped with their parents if their values are perfectly nested using the following custom legend handler.plugins: { legend: { labels: { generateLabels: chart =&gt; chart.data.labels.map((l, i) =&gt; ({ text: l, index: i, fillStyle: chart.data.datasets[0].backgroundColor[i], strokeStyle: chart.data.datasets[0].backgroundColor[i], hidden: chart.getDatasetMeta(0).data[i].hidden })), }, onClick: (event, legendItem, legend) =&gt; { var start = 0; var end = 0; var sum = 0; let chart = legend.chart; let hidden = !chart.getDatasetMeta(0).data[legendItem.index].hidden; chart.getDatasetMeta(0).data[legendItem.index].hidden = hidden; chart.data.datasets[0].data.forEach((v, i) =&gt; { var value = chart.getDatasetMeta(0).data[i].$context.parsed; if (i == legendItem.index) { start = sum; end = sum + value; } sum += value; }); sum = 0; chart.data.datasets[1].data.forEach((v, i) =&gt; { var value = chart.getDatasetMeta(1).data[i].$context.parsed; sum += value; if (sum &gt; start &amp;&amp; sum &lt;= end) { chart.getDatasetMeta(1).data[i].hidden = hidden; } }); chart.update(); } }}ResultThe complete code for this example can be found here.Toggle Nested DataThe nested data can also be toggled on and off by creating a simple function.document.getElementById('nested').addEventListener('click', () =&gt; { if (data.datasets[1].hasOwnProperty(\"hidden\") &amp;&amp; data.datasets[1].hidden == true) { data.datasets[1].hidden = false; } else { data.datasets[1].hidden = true; } myChart.update();});This function will toggle the nested data visiblity when the following button is pressed.&lt;button id=\"nested\" class=\"button\"&gt;Toggle Nested&lt;/button&gt;ResultThe complete code for this example can be found here.Toggle NestedSwitch datasetsTo show multiple datasets on the graph switching functionality has to be implemented.The first step is to move the datasets to a new object.const datasets = [ [{ data: [300, 50, 100], backgroundColor: [ 'rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 205, 86)' ] }, { data: [150, 150, 50, 75, 25], backgroundColor: [ 'rgb(255, 99, 132)', 'rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 205, 86)', 'rgb(255, 205, 86)' ] }], [{ data: [150, 100, 200], backgroundColor: [ 'rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 205, 86)' ] }, { data: [150, 25, 75, 100, 50, 50], backgroundColor: [ 'rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(54, 162, 235)', 'rgb(255, 205, 86)', 'rgb(255, 205, 86)', 'rgb(255, 205, 86)' ] }]]The data object then needs to point to the first entry in datasets.const data = { labels: [ 'Red', 'Blue', 'Yellow' ], datasets: datasets[0]};To switch between these datasets a new function is required.document.getElementById('dataset').addEventListener('click', () =&gt; { if (datasets.indexOf(data.datasets) == -1 || datasets.indexOf(data.datasets) == 1) { data.datasets = datasets[0] } else { data.datasets = datasets[1] } myChart.update();});This function will switch the visible dataset when the following button is pressed.&lt;button id=\"dataset\" class=\"button\"&gt;Switch Dataset&lt;/button&gt;The toggle nested function will need to be updated so that both datasets share the same view.document.getElementById('nested').addEventListener('click', () =&gt; { if (data.datasets[1].hasOwnProperty(\"hidden\") &amp;&amp; data.datasets[1].hidden == true) { datasets[0][1].hidden = false; datasets[1][1].hidden = false; } else { datasets[0][1].hidden = true; datasets[1][1].hidden = true; } myChart.update();});ResultThe complete code for this example can be found here.Toggle NestedSwitch DatasetInner textTo display additional text within the donut chart a Chart.js plugin must be created.This plugin can be assigned to any graph and can be customised to display specific text with automatic resising to remain within the available space.The specific plugin used is a slight modification to the answer posted by Shawn Corrigan.The plugin script will calculate the available width and adjust the font-size and line-breaks so that the text fills the available space.const countPlugin = { id: 'doughnut-centertext', beforeDraw: function(chart) { if (chart.config.options.elements.center) { // Get ctx from string var ctx = chart.ctx; var innerRadius = chart._metasets[chart._metasets.length - 2].controller.innerRadius; if (chart._metasets[chart._metasets.length - 1].controller.innerRadius &gt; 0) { innerRadius = chart._metasets[chart._metasets.length - 1].controller.innerRadius; } // Get options from the center object in options var centerConfig = chart.config.options.elements.center; var fontStyle = centerConfig.fontStyle || 'Arial'; var txt = centerConfig.text; var color = centerConfig.color || '#000'; var maxFontSize = centerConfig.maxFontSize || 75; var sidePadding = centerConfig.sidePadding || 20; var sidePaddingCalculated = (sidePadding / 100) * (innerRadius * 2) // Start with a base font of 30px ctx.font = \"30px \" + fontStyle; // Get the width of the string and also the width of the element minus 10 to give it 5px side padding var stringWidth = ctx.measureText(txt).width; var elementWidth = (innerRadius * 2) - sidePaddingCalculated; // Find out how much the font can grow in width. var widthRatio = elementWidth / stringWidth; var newFontSize = Math.floor(30 * widthRatio); var elementHeight = (innerRadius * 2); // Pick a new font size so it will not be larger than the height of label. var fontSizeToUse = Math.min(newFontSize, elementHeight, maxFontSize); var minFontSize = centerConfig.minFontSize; var lineHeight = centerConfig.lineHeight || 25; var wrapText = false; if (minFontSize === undefined) { minFontSize = 30; } if (minFontSize &amp;&amp; fontSizeToUse &lt; minFontSize) { fontSizeToUse = minFontSize; wrapText = true; } // Set font settings to draw it correctly. ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; var centerX = ((chart.chartArea.left + chart.chartArea.right) / 2); var centerY = ((chart.chartArea.top + chart.chartArea.bottom) / 2); ctx.font = fontSizeToUse + \"px \" + fontStyle; ctx.fillStyle = color; if (!wrapText) { ctx.fillText(txt, centerX, centerY); return; } var words = txt.split(' '); var line = ''; var lines = []; // Break words up into multiple lines if necessary for (var n = 0; n &lt; words.length; n++) { var testLine = line + words[n] + ' '; var metrics = ctx.measureText(testLine); var testWidth = metrics.width; if (testWidth &gt; elementWidth &amp;&amp; n &gt; 0) { lines.push(line); line = words[n] + ' '; } else { line = testLine; } } // Move the center up depending on line height and number of lines centerY -= (lines.length / 2) * lineHeight; for (var n = 0; n &lt; lines.length; n++) { ctx.fillText(lines[n], centerX, centerY); centerY += lineHeight; } //Draw text in center ctx.fillText(line, centerX, centerY); } }};The chart options also need to be updated to include the displayed text and styling options.plugins: [countPlugin],options: { elements: { center: { text: \"Inner Text\", color: '#00a3d3', fontStyle: 'Arial', sidePadding: 30, minFontSize: false } }}ResultThe complete code for this example can be found here.Toggle NestedSwitch DatasetSondeHub Listener Stats APIThe SondeHub Listener Stats API returns information about the number of receiver stations that have uploaded telemetry to the SondeHub radiosonde tracking database.The API can be integrated with the chart to ensure that the latest information is always shown.The specific Python code and Elasticsearch Query for generating the API response can be found here.https://api.v2.sondehub.org/listeners/stats{ \"radiosonde_auto_rx\": { \"telemetry_count\": 46867907, \"unique_callsigns\": 620, \"versions\": { \"1.5.10\": { \"telemetry_count\": 31942436, \"unique_callsigns\": 390 }, \"1.5.9\": { \"telemetry_count\": 5278005, \"unique_callsigns\": 73 }, \"1.5.8\": { \"telemetry_count\": 2554674, \"unique_callsigns\": 55 } } }, \"rdzTTGOsonde\": { \"telemetry_count\": 11768771, \"unique_callsigns\": 221, \"versions\": { \"devel20220426\": { \"telemetry_count\": 3854971, \"unique_callsigns\": 71 }, \"master_v0.9.1\": { \"telemetry_count\": 3628923, \"unique_callsigns\": 67 }, \"devel20220123\": { \"telemetry_count\": 1931191, \"unique_callsigns\": 33 } } }, \"SondeMonitor\": { \"telemetry_count\": 100335, \"unique_callsigns\": 10, \"versions\": { \"6.2.6.1\": { \"telemetry_count\": 26773, \"unique_callsigns\": 6 }, \"6.2.5.8\":{ \"telemetry_count\": 184, \"unique_callsigns\": 2 }, \"6.2.4.7\":{ \"telemetry_count\": 73262, \"unique_callsigns\": 1 } } }, \"totals\": { \"unique_callsigns\": 847, \"telemetry_count\": 58737217 }}Swagger UI APIThe following Swagger UI component can be used to access the SondeHub Listener Stats API and get real results.Working ExampleThe following JSFiddle contains a fully working demo incorportating everything discussed in this post.You can also find the complete source code on the sondehub-listener-stats GitHub page. MODE VERSIONS " } ]
